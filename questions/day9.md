# 速记第9天 - (JS性能)
1. JS的垃圾回收机制？
   内存分配回收是自动的，垃圾回收器定时找出不再使用的数据(变量，函数等)，释放内存空间

   **两种回收检测模式**
   引用计数： 清除没有任何引用指向的数据。无法处理循环引用。IE6使用

   标记清除： 标记可达数据，清除不可达数据。可处理循环引用。现代浏览器广泛使用
    - 从根出发：包括 全局变量、本地函数的局部变量、参数、调用链上其它函数的局部变量和函数等
    - 标记相连的对象为可达和访问过
    - 直到引用链上没有未访问过的对象为止
    - 删除没有被标记过，即不可达对象

    标记清除的优化：标记清除存在内存不连续，回收效率低，偶尔卡顿的缺点
     - 只在CPU空间时进行
     - 分代回收
       - 新生代：存活时间短，新生或经过一次垃圾回收的对象
           - 新生代：存活时间短，新生或经过一次垃圾回收的对象
               - 复制：复制 From 的可达对象 到 To 空间，释放 不可达对象
               - 晋升：复制时，To 空间使用超过 25%，晋升到 老生代
               - 交换 From 和 To 空间
       - 老生代：存活时间长，经过一次被晋升或多次垃圾回收的对
           - 标记清除
           - 标记整理：清除阶段先整理，将可达对象连续放置一起，再释放之外的内存
           - 增量标记：用增量标记代替全暂停，在回收间歇执行应用逻辑，避免卡顿]

    **参考资料**
    [你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)

2. 标记整理算法的步骤？
   - 标记完成
   - 存活对象向内存空间一端移动
   - 移动完成，清理掉边界外的所有内存


3. 前端常见的内存溢出途径，如何避免？
   
   **内存溢出**
   占用内存且无法被垃圾回收机制回收对象，容易导致内存溢出（泄漏），让应用程序占用本应回收或不需要占用的内存

   **途径**
   意外的全局变量： 全局变量是标记清除中的「根」，除非定义为空 或 重新分配，不可回收
        非严格模式下，没有使用 var let const 声明的变量
        挂载在 this 下的属性
   避免方式： 尽量不使用全局变量，在 JavaScript 头部使用严格模式

   **未清除的定时器**
   setInterval 自身及其回调函数内的对象，即使不被引用，也需要计时器停止才能清除
   避免方式：使用 requestAnimationFrame / setTimeout +递归 代替 setInterval，并设置边界

   **删除不完全的对象**
   addEventListener 监听的对象已不可达，但监听没有移除。现代浏览器会自动移除
   JS 中引用了 DOM 对象，对象已从 DOM Tree 中移除，但 JS 中依旧保持引用
   避免方式： 移除对象前，移除监听。需大量监听对象，使用事件代理监听父元素，移除 DOM 后，设置引用该 DOM 的变量为空

   **闭包中使用函数引用了可从根访问的父级变量**
   ```js
   var global = 0
   function closure () {
        let fromGlobal = global // 引用全局变量 global
        function unused () { // 闭包内不使用的函数
            if (fromGlobal) return // 引用父级变量 fromGlobal，导致 unused 占用内存
        }
        global = {} // 每次调用闭包 global 都会重新赋值
        /** 避免 **/
        fromGlobal = null
        closure()
    }

   ```

